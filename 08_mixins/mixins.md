# Миксины в Python

Согласно [определению в Википедии](https://en.wikipedia.org/wiki/Mixin),
миксины добавляют в класс методы без наследования
(without having to be parent class).
По иронии, в Python миксины работают как раз через наследование:
```Python
class Child(MixinA, MixinB, Parent):
    ...
```
На уровне синтаксиса они ничем не отличаются от других родительских классов,
поэтому, чтобы отличить смешивание от наследования
нужно подняться на уровень логики.
На этом уровне мы можем сказать, что `Child` **is a** `Parent` но при этом
`Child` **is not a** `MixinA` или `MixinB`.

Если миксины просто добавляют новое поведение, то порядок перечисления
базовых классов не важен.
Если же они должны переопределять или использовать методы родительского класса
или друг друга, то нужно учитывать порядок поиска вызываемых методов
(method resolution order aka MRO).
Кое-где встречаются упоминания, что для этого используется поиск в ширину
по дереву наследования, но на самом деле
[алгоритм немного другой](https://habr.com/ru/post/62203/).

В [моём примере](mixins.py) как раз взаимодействуют друг с другом,
и их порядок важен.
Рассмотрим класс `Veteran`:
```Python
class Veteran(FactorWeaponDamageModifier, FavoriteWeaponDamageModifier, WeaponHolder, Hero):
    
    def __init__(self) -> None:
        super().__init__()
        self.set_favorite_weapon("sword")
        self.set_weapon_damage_factor(1.5)
```

Его родительским классом является `Hero`.

Далее к нему добавляется функция ношения оружия с помощью миксина `WeaponHolder`.
Этот класс добавляет своё состояние (тип оружия),
методы для управления им (`set_weapon`, `get_weapon`),
и метод получения данных об уроне (`get_damage`).

Следующая примесь - `FavoriteWeaponDamageModifier` - удваивает урон
от любимого оружия (в данном случае - от меча).
Согласно MRO этот класс "прячет" метод `get_damage` класса `WeaponHolder`
за своим методом с тем же именем.
При этом он может вызвать `WeaponHolder.get_damage` с помощью конструкции
`super().get_damage()`.
Метод `super` в Python возвращает вовсе не родительский класс,
а следующий класс в MRO.

Последний миксин - `FactorWeaponDamageModifier` -
умножает урон от любого оружия на некоторую величину (в данном случае 1.5).
Здесь снова используется конструкция `super().get_damage()`,
только теперь она вызывает метод `FavoriteWeaponDamageModifier.get_damage`,
который вызывает `WeaponHolder.get_damage`.
Так можно строить цепочки любой длины.

Состояния в двух последних миксинах хорошо бы предавать в конструкторах и "заморозить",
но тогда пришлось бы убрать из всех миксинов строку `super().__init__()`
и вызывать все конструкторы в классе `Veteran` вручную.
Практика показывает, что в случае миксинов лучше все конструкторы делать без параметров. 

Если очень хочется отключить модификацию состояний,
то лучше сделать это в самом миксине.
Или можно использовать питоновскую магию:
```Python
class Veteran(FactorWeaponDamageModifier, FavoriteWeaponDamageModifier, WeaponHolder, Hero):
    
    def __init__(self) -> None:
        super().__init__()
        self.set_favorite_weapon("sword")
        self.set_weapon_damage_factor(1.5)
        # Убираем эти методы у данного объекта, больше их нельзя будет вызвать
        self.set_favorite_weapon = None
        self.set_weapon_damage_factor = None
```
