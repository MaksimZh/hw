# Минимизируем шаги изменений

## Задача 1: добавление статусов к методам с помощью декораторов
- [код](https://github.com/MaksimZh/sintez/blob/master/tools.py)
- [тесты](https://github.com/MaksimZh/sintez/blob/master/test_tools.py)

В первом курсе по объектно-ориентированному проектированию
я научился разделять методы на конструкторы, команды и запросы,
а также сохранять информацию об их работе с помощью статусов.
Я стал применять эту практику в своём рабочем проекте,
и добавлять статусы быстро надоело.
Тогда я решил выделить этот механизм в отдельную абстракцию,
чтобы можно было писать так:
```Python
class ADT(Status):
    @status("OK", "ERR")
    def command(self) -> None:
        self._set_status("command", "OK")

...

a = ADT()
a.command()
assert a.is_status("command", "OK")
```
вместо этого
```Python
class ADT:
    def __init__(self) -> None:
        self.__command_status = self.CommandStatus.NIL
    
    def command(self) -> None:
        self.__command_status = self.CommandStatus.OK

    class CommandStatus(Enum):
        NIL = auto(),
        OK = auto(),
        ERR = auto(),

    __command_status: CommandStatus

    def get_command_status(self):
        return __command_status

...

a = ADT()
a.command()
assert a.get_command_status() == "OK"
```

Вначале изменения были небольшими, но и их можно было разбить на более мелкие.

Например, при добавлении проверки значений статусов в существующие методы
был добавлен новый запрос (`is_status`). Это уже два разных действия.

Под конец всё-таки "сорвался" и добавил наследование статусов целиком,
хотя можно было разбить это действие на 3-4 шага.
Фактически, эти шаги были, только между ними не было коммитов.

Отмечу, что это было первое в моей практике масштабное тестирование
генерации исключений.
Код, в котором используются неверные имена и значения статусов считается
сломанным на уровне логики и не должен запускаться.
Поэтому использовалась конструкция `assert`, которая отключена в релизе.


## Задача 2: модификация дизайна узлов схемы расчёта
- [код](https://github.com/MaksimZh/sintez/blob/master/nodes.py)
- [тесты](https://github.com/MaksimZh/sintez/blob/master/test_nodes.py)

Ночью во сне пришла идея как улучшить внутреннюю логику этого важнейшего
для моих рабочих проектов кода.

Старая версия: 
- хранилище данных "знает", что данные обновились;
- хранилище данных "помнит", каким процедурам отправлялась обновлённая версия;
- процедура сообщает хранилищу об использовании данных.

Это не очень хорошо, так как данные новые или старые не сами по себе,
а относительно использующих их процедур.
Ответственность за эту информацию лучше передать процедурам, а не хранилищу.

Новая версия:
- хранилище данных отвечает только за актуальность значений
  (обновлялись ли они после изменения входных параметров);
- хранилище данных сообщает зависимым процедурам об изменении данных;
- процедура "знает", какие из её входных данных менялись
  с момента последнего запуска, и избегает повторных расчётов на основе этой информации.

В первом коммите я вообще не трогал код, а только переписал комментарии,
содержащие информацию уровня логики.
Фактически - изменилась только проектная документация.
При этом с помощью TODO-комментариев какие-то элементы кода были помечены
как устаревшие, а где-то выделены места для вставки нового кода.

Далее я изменил первый тест так, чтобы он использовал обновлённый интерфейс.
Конечно же он выдал ошибку - такого запроса в реализации АТД ещё не было.
После добавления запроса и успешного прохождения теста настала очередь других тестов.
Старый интерфейс оставался на месте, и тесты можно было менять по одному.

В какой-то момент для прохождения тестов пришлось добавлять параметр
к существующей команде.
Руки чесались реализовать сразу всю логику, но для прохождения тестов это было
не нужно.

Когда какие-то части интерфейса больше не использовались в тестах, я их удалял.

В какой-то момент логика ещё была недоделана, но тесты проходили.
Тогда был добавлен новый тест, который требовал полной реализации новой логики,
а иначе он выдавал ошибку.
Только после этого я реализовал недостающие элементы логики.


## Выводы
Минимизация шагов изменений помогает лучше понять задачу
и провести декомпозицию даже на уровне логики:
выделить элементы поведения, которые могут быть реализованы и протестированы
отдельно.

Гораздо приятнее вносить небольшие изменения, после которых все тесты проходят,
чем часами сидеть над кодом, перекрашенным линтером во все оттенки красного.
Это положительно влияет на эмоциональное состояние и на продуктивность.
