# Ясный код-2

## 2. Уровень классов.

### 2.1. Класс слишком большой (нарушение SRP), или в программе создаётся слишком много его инстансов (подумайте, почему это плохой признак).
Если в игре сделать сначала только боевых персонажей, а потом начать добавлять
стационарные турели, медиков, нейтральных юнитов и т.п. не меняя архитектуру,
то получится нечто такое:
```Python
class Unit:
    ...

    def can_mode(self) -> bool:
        ...

    def has_weapon(self) -> bool:
        ...

    def has_medkit(self) -> bool:
        ...
```
В этом классе собрана логика движения, лечения, работы с оружием и всё остальное.

Под каждый юнит будет создаваться объект этого класса и их станет слишком много.
Тут имеем сразу обе проблемы.

В общем случае, если создаётся слишком много инстансов одного класса,
то, вероятно, предметная область плохо поделена на сущности.
Можно выделить подтипы и инстансов каждого из них будет меньше.


### 2.2. Класс слишком маленький или делает слишком мало.
В старой версии моей расчётной программы начали появляться классы такого вида:
```Python
class SumSolver(Solver):
    ... # обслуживание логики Solver

    def run(self) -> None:
        a = self.__a.get()
        b = self.__b.get()
        self.__result.put(a + b)
```
Отдельный класс для сложения двух величин делает слишком мало.

Решением было сделать класс-обёртку `Wrapper`,
который может применяться к любой функции и реализует всю логику
солвера автоматически:
```Python
def add(a: int, b: int) -> int:
    return a + b

SumSolver = Wrapper(add, ["result"])
```


### 2.3. В классе есть метод, который выглядит более подходящим для другого класса.
Опять из старых запасов:
```Python
class DataNode:
    ...

    def mark_used(self) -> None:
        ...
```
Были данные использованы или нет - это не свойство данных, а свойство процедуры.

Решением стало: добавить класс для аргументов процедуры и поместить
признак "использованности" туда.


### 2.4. Класс хранит данные, которые загоняются в него в множестве разных мест в программе.
Довелось немного поработать в проекте, где класс-одиночка `ParameterDatabase`
использовался для:
  - хранения мировых констант;
  - хранения входных данных;
  - хранения промежуточных результатов;
  - хранения результатов работы программы;
  - управления процессом вычислений с помощью флагов;
  - обмена данными со скриптами.

Внутри этого объекта (`pdb`) была древовидная структура данных
с динамической типизацией.
Прогамма наполовину состояла из `pdb->set(...)` и `pdb->get(...)`,
при этом компилятор C++ был лишён возможности предупреждать нас о нарушениях
системы типов.
В результае, часть ошибок на уровне кода обнаруживалась на уровне выполнения
(и не всегда сразу).


### 2.5. Класс зависит от деталей реализации других классов.
```Python
class ODEBuilder(Solver):
    ...

    def run() -> None:
        ...
        self.__result = ODE(Akima1DInterpolator(x, coefs))

class ODE:
    def __init__(self, coefs: Akima1DInterpolator) -> None
        ...

class ODESolver(Solver):
    
    def run() -> None:
        ...
        coefs = ode.get_coefs()(x)
        ...
```
Целых три класса знают, что коэффициенты задаются сплайном Акимы.

Лучше так:
```Python
class ODEBuilder(Solver):
    ...

    def run() -> None:
        ...
        self.__result = ODE(x, coefs)

class ODE:
    def __init__(self, x_mesh: NDArray, coefs_mesh: NDArray) -> None
        self.__spline = Akima1DInterpolator(x_mesh, coefs_mesh)
        ...

    def get_coefs(self, x) -> NDArray:
        return self.__spline(x)

class ODESolver(Solver):
    
    def run() -> None:
        ...
        coefs = ode.get_coefs(x)
        ...
```
Теперь конкретная реализация получения непрерывной функции спрятана внутри `ODE`.


### 2.6. Приведение типов вниз по иерархии (родительские классы приводятся к дочерним).
```Python
class Unit:
    ...

class Human(Unit):
    def heal(self):
        ...

class Robot(Unit):
    def repair(self):
        ...

def restore(unit: Unit):
    if isinstance(unit, Human):
        unit.heal()
        return
    if isinstance(unit, Robot):
        unit.repair()
        return
```
Лучше сделать `restore` абстрактным методом класса `Unit`.


### 2.7. Когда создаётся класс-наследник для какого-то класса, приходится создавать классы-наследники и для некоторых других классов.
Что-то подобное ждёт меня в моём проекте:
```Python
# Модель полупроводниковой структуры и её подтипы
class Sample:
    ...

class BulkSample(Sample):
    ...

class LayerSample(Sample):
    ...

# Для вычислений нужны принципиально разные алгоритмы
class HamiltonianBuilder(Solver):
    ...

class BulkHamiltonianBuilder(HamiltonianBuilder):
    ...

class LayerHamiltonianBuilder(HamiltonianBuilder):
    ...
```
Пока не придумал, как это обойти.


### 2.8. Дочерние классы не используют методы и атрибуты родительских классов, или переопределяют родительские методы.
```Python
class Rectangle:

    def set_height(self, value: int) -> None:
        self.__height = value
    
    def set_width(self, value: int) -> None:
        self.__width = value

class Square:

    def set_height(self, value: int) -> None:
        self.__height = value
        self.__width = value
    
    def set_width(self, value: int) -> None:
        self.__height = value
        self.__width = value
```
Классический пример нарушения LSP.
В классе-потомке переопределяется не только реализация но и спецификация методов.


## 3. Уровень приложения.

### 3.1. Одна модификация требует внесения изменений в несколько классов.
В старой версии моей расчётной программы вместо своих АТД использовались
массивы с именованными размерностями из библиотеки `xarray` для `Python`.
Много информации кодировалось в именах этих размерностей и при изменении этой
кодировки приходилось менять все солверы.

Правильное решение - выделить важную информацию в отдельные атрибуты АТД,
тогда не надо ничего кодировать.


### 3.2. Использование сложных паттернов проектирования там, где можно использовать более простой и незамысловатый дизайн.
В очень старой версии расчётной программы я экспериментировал с паттерном
Entity Component System.
Когда у узла графа есть компоненты `inputs` и `outputs` наличие которых
необходимо проверять - это уже перебор.
