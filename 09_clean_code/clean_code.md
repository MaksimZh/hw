# Ясный код

## 1.1. Методы, которые используются только в тестах
```Python
class ValueNode:

    __input: Optional["ProcedureNode"]
    __outputs: set["ProcedureNode"]

    ...

    def get_input(self) -> Optional["ProcedureNode"]:
        return self.__input

    def get_outputs(self) -> set["ProcedureNode"]:
        return self.__outputs.copy()


class ProcedureNode:

    __inputs: dict[str, ValueNode]
    __outputs: dict[str, ValueNode]

    ...

    def get_inputs(self) -> dict[str, "ValueNode"]:
        return self.__inputs.copy()

    def get_outputs(self) -> dict[str, "ValueNode"]:
        return self.__outputs.copy()
```

Запросы `get_...` использовались только в тестах, потому что алгоритмы,
работающие с графом этих узлов, были распределены между методами внутри узлов.
Эти методы обращались к полям класса напрямую, поэтому запросы использовались
только в тестах, чтобы убедиться, что узлы связаны правильно.

Сначала такая распределённая реализация алгоритмов казалась хорошим решением,
так как задача разбивалась на подзадачи.
Однако, тут есть проблемы сразу на всех уровнях:
  - Во **время выполнения** при вызове метода одного из узлов происходят вызовы
    методов соседних узлов и т.д.
    В результате, сбой в работе узла на одном конце графа нарушает работу узла
    на другом конце.
    Отлаживать такое - врагу не пожелаешь.
  - На **уровне реализации** очень сложно собрать в голове код решения задачи,
    когда решения подзадач разбросаны по методам в разных классах.
    Разделённая реализация не отображает в коде единую логику алгоритма.
    И да, появляются *методы, которые используются только в тестах*.
  - На **уровне логики** оказалось очень сложно (если вообще возможно) построить
    чёткие математические формулировки пред- и постусловий методов.
    Предусловия вида "обновление входных узлов будет успешным",
    и постусловия вида "для выходных узлов вызван метод `invalidate`" -
    плохо поддаются верификации и дают мало информации о состоянии узла.
    Получается, что на уровне логики каждый объект содержит в себе весь граф,
    то есть, декомпозиция задачи не состоялась.

В новом коде в узлах осталась только логика связей и состояний самих узлов.
Теперь запросы связей используются внешними функциями, а не только тестами.


## 1.2. Цепочки методов
Вот другой срез кода из предыдущего примера:
```Python
class ValueNode:

    __input: Optional["ProcedureNode"]
    __outputs: set["ProcedureNode"]

    ...
    
    def put(self, value: Any) -> None:
        ...
        for output in self.__outputs:
            output.invalidate(self)
    
    def invalidate(self) -> None:
        ...
        for output in self.__outputs:
            output.invalidate(self)
    
    def validate(self) -> None:
        ...
        self.__input.validate()
        ...


class ProcedureNode:

    __inputs: dict[str, ValueNode]
    __outputs: dict[str, ValueNode]

    ...

    def invalidate(self, input: ValueNode) -> None:
        ...
        for output in self.__outputs.values():
            output.invalidate()

    def validate(self) -> None:
        ...
        for input in self.__inputs.values():
            input.validate()
        ...
        for name, output in self.__outputs.items():
            ...
            output.put(value)
            ...
```

Это больше, чем просто цепочка методов,
ЭТО распространяется на множество объектов.
Команды `validate` и `invalidate` вызывают аналогичные команды у соседних узлов
и далее, возможно, на всю глубину графа.

О недостатков такого решения написано выше.
Интересно, что это другое следствие той же самой ошибки на уровне логики.
Вывел для себя правило:
> Если логика решения плохо поддаётся математической формализации,
> нужно пересмотреть решение.

Поскольку источник проблемы тот же, то и лекарство то же -
вынести алгоритмы из классов узлов.


## 1.3. У метода слишком большой список параметров
```Python
class Simulator(Procedure):
    
    ...

    def __add_input(self,
            proc: ProcedureNode,
            slot_name: str,
            value: ValueNode
            ) -> None:
        ...

    def __add_output(self,
            proc: ProcedureNode,
            slot_name: str,
            value: ValueNode
            ) -> None:
        ...

```
Эти методы так выглядят из-за того, что связи в графе именованные,
и имена хранятся в одном из типов узлов.
Вообще, отдельные методы понадобились только потому, что нужно проверить,
есть ли у процедуры такой слот, подходит ли его тип и т.д.

Решение - вынести слоты в отдельные узлы, которые создаются на основе
информации о процедуре, тогда у нас просто будут узлы с правильными именами
и типами.
Тогда эти методы вообще не нужны, ибо каждый из них можно заменить небольшим блоком:
```Python
if not _type_fits(output_node.get_type(), input_node.get_type()):
    ...
output_node.add_output(input_node)
input_node.add_input(output_node)
```
